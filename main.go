package main

import (
	"flag"
	"fmt"
	"io/fs"
	"os"
	"path"
	"path/filepath"
	"strings"

	"github.com/emcfarlane/starlarkproto"
	"go.starlark.net/starlark"
	"go.starlark.net/starlarkstruct"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/reflect/protoregistry"
	"sigs.k8s.io/yaml"
)

var (
	flagOutDir  = flag.String("out", "", "Out directory.")
	flagGlobal  = flag.String("global", "", "Global starlark file.")
	flagVerbose = flag.String("v", "", "Verbose mode.")
)

func run() error {
	flag.Parse()

	args := os.Args[1:] // kubestar examples/nginx_deployment.star -> examples/nginx_deploment.yaml
	if len(args) != 1 {
		return fmt.Errorf("missing files glob: e.g. \"*.star\"")
	}
	pattern := args[0]
	if _, err := path.Match(pattern, ""); err != nil {
		return err // invalid pattern
	}

	fsys := os.DirFS(".")

	globals := starlark.StringDict{
		"struct": starlark.NewBuiltin("struct", starlarkstruct.Make),
		"proto":  starlarkproto.NewModule(protoregistry.GlobalFiles),
	}

	loader := NewLoader(fsys, globals)

	if *flagGlobal != "" {
		thread := &starlark.Thread{
			Name: *flagGlobal,
			Load: loader.Load,
		}
		values, err := loader.Load(thread, *flagGlobal)
		if err != nil {
			return err
		}
		for k, v := range values {
			globals[k] = v
		}
	}

	files, err := fs.Glob(fsys, pattern)
	if err != nil {
		return err
	}

	protos := make(map[string][]*starlarkproto.Message, len(files))
	for _, name := range files {

		thread := &starlark.Thread{
			Name: name,
			Load: loader.Load,
		}
		values, err := loader.Load(thread, name)
		if err != nil {
			return err
		}

		mainFn, ok := values["main"]
		if !ok {
			continue
		}
		v, err := starlark.Call(thread, mainFn, nil, nil)
		if err != nil {
			return err
		}

		switch v := v.(type) {
		case *starlarkproto.Message:
			protos[name] = append(protos[name], v)
		case *starlark.List:
			for i := 0; i < v.Len(); i++ {
				vpb, ok := v.Index(i).(*starlarkproto.Message)
				if !ok {
					return fmt.Errorf("%s: expected *starlarkproto.Message got %T", name, vpb)
				}
				protos[name] = append(protos[name], vpb)
			}
		default:
			return fmt.Errorf("%s: expected *starlarkproto.Message got %T", name, v)
		}

	}

	// encode to yaml
	for name, vpbs := range protos {
		if err := encode(name, vpbs); err != nil {
			return err
		}
	}
	return nil
}

const yamlTmpl = `# Code generated by kubestar. DO NOT EDIT.
# source: %s
`

const objTmpl = `apiVersion: %s
kind: %s
`

func encode(name string, protos []*starlarkproto.Message) error {
	filename := path.Join(
		*flagOutDir,
		strings.TrimSuffix(
			name, filepath.Ext(name),
		),
	) + ".yaml"

	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()

	for i, vpb := range protos {
		if i == 0 {
			if _, err := fmt.Fprintf(
				f, yamlTmpl, name,
			); err != nil {
				return err
			}
		} else {
			if _, err := f.WriteString("---\n"); err != nil {
				return err
			}
		}

		jb, err := protojson.Marshal(vpb)
		if err != nil {
			return err
		}

		yb, err := yaml.JSONToYAML(jb)
		if err != nil {
			return err
		}

		// encode resource information:
		// https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#resources
		md := vpb.ProtoReflect().Descriptor()
		kind := string(md.Name())
		apiVersion := strings.ReplaceAll(
			strings.TrimSuffix(
				strings.TrimPrefix(
					string(md.FullName()),
					"k8s.io.api.",
				),
				"."+string(md.Name()),
			),
			".", "/",
		)
		if _, err := fmt.Fprintf(
			f, objTmpl, apiVersion, kind,
		); err != nil {
			return err
		}

		if _, err := f.Write(yb); err != nil {
			return err
		}
		fmt.Println(filename)
	}
	return nil
}

func main() {
	if err := run(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}
