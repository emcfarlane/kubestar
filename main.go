package main

import (
	"context"
	"flag"
	"fmt"
	"io/fs"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"strings"
	"testing"

	"github.com/emcfarlane/larking/starlarkproto"
	"github.com/emcfarlane/larking/starlarkthread"
	"github.com/emcfarlane/larking/starlib"
	"github.com/emcfarlane/starlarkassert"
	"go.starlark.net/starlark"
	"google.golang.org/protobuf/encoding/protojson"
	"sigs.k8s.io/yaml"
)

var (
	flagOutDir = flag.String("out", "", "Out directory.")
)

func run(ctx context.Context) error {
	ctx, cancel := context.WithCancel(ctx)
	defer cancel()

	flag.Parse()

	args := os.Args[1:] // kubestar examples/nginx_deployment.star -> examples/nginx_deploment.yaml
	if len(args) != 1 {
		return fmt.Errorf("missing files glob: e.g. \"*.star\"")
	}
	pattern := args[0]
	if _, err := path.Match(pattern, ""); err != nil {
		return err // invalid pattern
	}

	globals := starlib.NewGlobals()
	loader := starlib.NewLoader()
	defer loader.Close()

	runner := func(t testing.TB, thread *starlark.Thread) func() {
		thread.Load = loader.Load

		starlarkthread.SetContext(thread, ctx)

		close := starlarkthread.WithResourceStore(thread)
		return func() {
			if err := close(); err != nil {
				t.Error(err)
			}
		}
	}

	fsys := os.DirFS(".")
	var tests []testing.InternalTest
	files, err := fs.Glob(fsys, pattern)
	if err != nil {
		return err
	}

	protos := make(map[string]*starlarkproto.Message, len(files))
	for _, name := range files {
		src, err := fs.ReadFile(fsys, name)
		if err != nil {
			return err
		}

		// Run.
		thread := &starlark.Thread{
			Name: name,
			Load: loader.Load,
		}
		starlarkthread.SetContext(thread, ctx)
		defer starlarkthread.WithResourceStore(thread)()

		module, err := starlark.ExecFile(
			thread, name, src, globals)
		if err != nil {
			return err
		}
		mainFn, ok := module["main"]
		if !ok {
			continue
		}
		v, err := starlark.Call(thread, mainFn, nil, nil)
		if err != nil {
			return err
		}
		vpb, ok := v.(*starlarkproto.Message)
		if !ok {
			return fmt.Errorf("%s: expected *starlarkproto.Message got %T", name, vpb)
		}
		protos[name] = vpb

		tests = append(tests, testing.InternalTest{
			Name: name,
			F: func(t *testing.T) {
				starlarkassert.TestFile(
					t, name, src, globals, runner,
				)
			},
		})
	}

	// testing
	var (
		matchPat string
		matchRe  *regexp.Regexp
	)
	deps := starlarkassert.MatchStringOnly(
		func(pat, str string) (result bool, err error) {
			if matchRe == nil || matchPat != pat {
				matchPat = pat
				matchRe, err = regexp.Compile(matchPat)
				if err != nil {
					return
				}
			}
			return matchRe.MatchString(str), nil
		},
	)
	if testing.MainStart(deps, tests, nil, nil, nil).Run() > 0 {
		return fmt.Errorf("failed")
	}

	// save files
	for name, vpb := range protos {
		filename := path.Join(
			*flagOutDir,
			strings.TrimSuffix(
				name, filepath.Ext(name),
			),
		) + ".yaml"

		jb, err := protojson.Marshal(vpb)
		if err != nil {
			return err
		}

		md := vpb.ProtoReflect().Descriptor()

		// yaml.JSONToYAML
		var jsonObj map[string]interface{}
		if err := yaml.Unmarshal(jb, &jsonObj); err != nil {
			return err
		}
		// encode resource information:
		// https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#resources
		jsonObj["kind"] = string(md.Name())
		jsonObj["apiVersion"] = strings.ReplaceAll(
			strings.TrimSuffix(
				strings.TrimPrefix(
					string(md.FullName()),
					"k8s.io.api.",
				),
				"."+string(md.Name()),
			),
			".", "/",
		)
		yb, err := yaml.Marshal(jsonObj)
		if err != nil {
			return err
		}

		create := func(b []byte) error {
			f, err := os.Create(filename)
			if err != nil {
				return err
			}
			defer f.Close()

			if _, err := f.WriteString(
				fmt.Sprintf(yamlTmpl, name),
			); err != nil {
				return err
			}

			if _, err := f.Write(
				b,
			); err != nil {
				return err
			}

			return nil
		}
		if err := create(yb); err != nil {
			return err
		}
	}
	return nil
}

const yamlTmpl = `# Code generated by kubestar. DO NOT EDIT.
# source: %s
`

func main() {
	ctx := context.Background()
	if err := run(ctx); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}
